\section{Аналитический раздел}
В данном разделе...

\subsection{Формализация цели}
Цель работы -- разработать загружаемый модуль ядра для мониторинга приоритетов, времени выполнения и простоя процессов на ОС Linux и проанализировать с использованием данного модуля воспроизведение аудиофайлов и видеофайлов.

Для достижения поставленной цели потребуется:
\begin{enumerate}[leftmargin=1.6\parindent]
\item проанализировать структуры ядра, позволяющие определить приоритет, время выполнения и простоя процессов;
\item проанализировать способы доступа к выбранным структурам ядра;
\item проанализировать методы передачи информации из модуля ядра в пространство пользователя;
\item спроектировать и реализовать загружаемый модуль ядра;
\item проанализировать с использованием реализованного модуля воспроизведение аудиофайлов и видеофайлов.
\end{enumerate}

\subsection{Понятие процесса реального времени}
Процесс реального времени -- это процесс, который имеет приоритет над обычными процессами. В Linux планирование процессов реального времени возложено на так называемый RT Scheduler (Real Time Scheduler -- планировщик реального времени), а обычные процессы обрабатываются с использованием CFS Scheduler (Completely Fair Scheduler -- совершенно честный планировщик). Работа данных планировщиков строится на работе с группами процессов, которые расположены в очередях, которые, в свою очередь, организованы в дерево. \cite{realtimeprocesses}

\subsection{Описание работы RT Scheduler}
Проблема планирования в режиме реального времени заключается в том, что группы процессов должны полагаться на постоянство объема полосы пропускания (например, времени исполнения). Для планирования нескольких групп задач в реальном времени может потребоваться назначение, так называемого, гарантированного доступного времени исполнения. \cite{linuxkerneldocs}

В качестве решения поставленной проблемы доступное процессорное время делится посредством указания того, сколько времени на исполнение даётся на указанный период. Данное время выделяется для каждой группы процессов реального времени, причём каждая группа может исполнятся только в свое выделенное время. \cite{linuxkerneldocs}

Время, не выделенное группам реального времени или неиспользованное ими, будет выделено задачами с обычным приоритетом (SCHED\_OTHER). \cite{linuxkerneldocs}

Для примера можно рассмотреть следующую задачу: рендерер реального времени с фиксированным количеством кадров должен выдавать 25 кадров в секунду, что дает период 0.04 секунды на каждый кадр. Если перед рендерером также стоит параллельная задача проигрывания музыки и ответа на ввод, оставляя около 80\% доступного процессорного времени, предназначенного для графики, то для этой группы можно выделить время выполнения $ 0.8 \cdot 0.04 = 0.032 $ секунды.

Таким образом, графическая группа будет иметь период 0.04 секунды с ограничением времени выполнения 0.032 секунды. Если аудиопотоку необходимо заполнять буфер DMA (Direct Memory Access, прямой доступ к памяти) каждые 0.005 секунд, но для этого требуется около 3\% времени процессора, ему может быть выделено время выполнения $ 0.03 \cdot 0.005 = 0.00015 $ секунд. Таким образом, данная группа может быть запланирована с периодом 0.005 секунд с временем выполнения 0.00015 секунд.

Оставшееся процессорное время будет использовано для ввода данных пользователем и других задач.

Однако на текущий момент приведенный выше пример еще не реализован полностью в силу того, что отсутствует реализация планировщика EDF (Erlienst Deadline First scheduling, алгоритм планирования по ближайшему сроку завершения) для использования неоднородных периодов. \cite{linuxkerneldocs}

\subsection{Структуры ядра}
Современные операционные системы предоставляют пользователю фундаментальные концепции, такие как, файл или процесс. \cite{linuxTasks}

С использованием документации представляется возможность получить доступ к данным концепциям и изучить работу системы изнутри.

\subsubsection{task\_struct}
Процесс состоит из нескольких компонентов \cite{linuxTasks}:
\begin{itemize}[leftmargin=1.6\parindent]
\item стек процесса;
\item регистры процессора, в которые загружены ключевые переменные (зависит от архитектуры);
\item адресное пространство;
\item ресурсы: дескрипторы открытых файлов, ожидающие обработки сигналы;
\item управляющие структуры ядра ОС.
\end{itemize}

Структура в ядре Linux, соответствующая каждому процессу, -- task\_struct. Она определена в файле include/linux/sched.h. Все процессы существующие в системе процессы объединены в кольцевой список. \cite{linuxTasks} 

Стоит отметить, что данная структура занимает в памяти порядка 1.7 килобайт.

Поля структуры содержат информацию о процессе, которую можно поделить на несколько категорий \cite{linuxTasks}:
\begin{itemize}[leftmargin=1.6\parindent]
\item поля, отвечающие за общую информацию о процессе (PID, exit\_code, PPID);
\item поля, востребованные планировщиком задач (prio, static\_prio, timeslice);
\item поля, связанные с безопасностью (uid, gid).
\end{itemize}

Структура task\_struct для Linux v5.16rc8 представлена в приложении (см. Приложение 1).

Далее будут отмечены наиболее информативные в проводимой работе поля данной структуры и их назначение.

\paragraph*{pid} (Process Identifier) -- уникальный идентификатор процесса. Каждый процесс в операционной системе имеет свой уникальный идентификатор, по которому можно получить информацию об этом процессе, а также направить ему управляющий сигнал или завершить \cite{losst}.

prio, static\_prio, normal\_prio, rt\_priority -- приоритеты процесса.

\paragraph*{prio} -- это значение, которое использует планировщик задач при выборе процесса. Чем ниже значение данной переменное, тем выше приоритет процесса (может принимать значения от 0 до 139, то есть MAX\_PRIO, значение которого вычисляется с использованием переменной MAX\_RT\_PRIO со значением 100) \cite{linuxPriority}. Также данный приоритет может быть поделён на два интервала:
\begin{itemize}[leftmargin=1.6\parindent]
\item от 0 до 99 -- процесс реального времени;
\item от 100 до 139 -- обычный процесс.
\end{itemize}

Также определены функции определения приоритета процесса, которые приведены в листинге \ref{code:prioFunctions}.

\begin{code}
	\captionof{listing}{Функции определения приоритета процесса, определенные в /kernel/sched.c}
	\label{code:prioFunctions}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/prios.h}
\end{code}

Из предоставленного листинга видно, что для процессов реального времени значение приоритета определяется с использованием поля prio, а в ином случае -- static\_prio.

\paragraph*{static\_prio} не изменяется ядром при работе планировщика, однако оно может быть изменено с использованием пользовательского приоритета nice. Макрос для изменения данного приоритета предоставлен в листинге \ref{code:nice}.

\begin{code}
	\captionof{listing}{Макрос для изменения static\_prio.}
	\label{code:nice}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/nice.h}
\end{code}

Таким образом, значение статического приоритета может быть изменено с использованием вызова макроса NICE\_TO\_PRIO(nice).

\paragraph*{normal\_prio} зависит от статического приоритета и политики планировщика задач. Для процессов не реального времени данное значение равняется значению статического приоритета static\_prio. Для процессов реального времени данное значение равняется значению, вычисленному с использованием максимального значения приоритета процесса реального времени и, непосредственно, его rt\_priority. Функция вычисления нормального приоритета предоставлена в листинге \ref{code:normal_prio}.

 \begin{code}
	\captionof{listing}{Функция вычисления нормального приоритета. }
	\label{code:normal_prio}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/normal.h}
\end{code}

Важно отметить факт того, что, чем больше значение rt\_priority, тем выше приоритет процесса.

\subsubsection{sched\_info} 
sched\_info -- структура, которая предоставляет информацию о планировании процесса:
\begin{itemize}[leftmargin=1.6\parindent]
\item количество запусков процесса на исполнение центральным процессором;
\item количество времени, проведенного в ожидании на исполнение;
\item время последнего запуска процесса на исполнение центральным процессором;
\item время последнего добавления процесса в очередь на исполнение.
\end{itemize}

Данная структура предоставлена в листинге \ref{code:sched}.

 \begin{code}
	\captionof{listing}{Структура sched\_info. }
	\label{code:sched}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/sched.h}
\end{code}

\paragraph*{utime} -- это время, проведенное в режиме пользователя и затраченное на запуск команд. Данное значение включает в себя только время, затраченное центральным процессором, и не включает в себя время, проведенное процессом в очереди на исполнение.

\paragraph*{stime} -- это время процессора, затраченное на выполнение системных вызовов при исполнении процесса.

\subsubsection{sched\_rt\_entity} 
sched\_rt\_entity -- это структура, используемая для группового планирования процессов реального времени, которое включает в себя деревья групп и их очередей. Данное решение позволяет определять выделяемую производительность процессора для определенных групп процессов.

Структура sched\_rt\_entity предоставлена в листинге \ref{code:sched}.

 \begin{code}
	\captionof{listing}{Структура sched\_rt\_entity. }
	\label{code:sched}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/sched_rt.h}
\end{code}

В данной структуре поле parent указывает на процесс более высокого уровня в дереве. rt\_rq -- это очередь, в которой процесс находится, а my\_q -- это очередь дочерних процессов.

Поле timeout изменяется так называемым watchdog таймером и используется для проверки того, что процесс не занимает процессор дольше, чем это задано в RLIMIT\_RTTIME.



\subsubsection*{Вывод}
В разделе...

\pagebreak