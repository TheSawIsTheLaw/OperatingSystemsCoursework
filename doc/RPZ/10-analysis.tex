\section{Аналитический раздел}

\subsection{Постановка задачи}
В соответствии с заданием на курсовую работу по курсу ``Операционные Системы'' необходимо разработать загружаемый модуль ядра, позволяющий отслеживать состояния приоритетов, времени выполнения и простоя процессов в операционной системе Linux и проанализировать с использованием данного модуля процессы реального времени.

Для решения поставленной задачи необходимо:
\begin{enumerate}[leftmargin=1.6\parindent]
\item проанализировать и выбрать структуры ядра, содержащие необходимую информацию;
\item проанализировать и выбрать методы передачи информации из модуля ядра в пространство пользователя;
\item разработать алгоритмы и структуру программного обеспечения;
\item проанализировать разработанное программное обеспечение.
\end{enumerate}

\subsection{Описание работы RT Scheduler}
Проблема планирования в режиме реального времени заключается в том, что группы процессов должны полагаться на постоянство объема полосы пропускания (например, времени исполнения). Для планирования нескольких групп задач в реальном времени может потребоваться назначение так называемого гарантированного доступного времени исполнения. \cite{linuxkerneldocs}

В качестве решения поставленной проблемы доступное процессорное время делится посредством указания того, сколько времени на исполнение даётся на указанный период. Данное время выделяется для каждой группы процессов реального времени, причём каждая группа может исполнятся только в свое выделенное время. \cite{linuxkerneldocs}

Время, не выделенное группам реального времени или неиспользованное ими, будет выделено задачам с обычным приоритетом (SCHED\_OTHER). \cite{linuxkerneldocs}

Рассмотрим пример: рендерер реального времени с фиксированным количеством кадров должен выдавать 25 кадров в секунду, что дает период 0.04 секунды на каждый кадр. Если перед рендерером также стоит параллельная задача проигрывания музыки и ответа на ввод, оставляя около 80\% доступного процессорного времени, предназначенного для графики, то для этой группы можно выделить время выполнения $ 0.8 \cdot 0.04 = 0.032 $ секунды.

Таким образом, графическая группа будет иметь период 0.04 секунды с ограничением времени выполнения 0.032 секунды. Если аудиопотоку необходимо заполнять буфер DMA (Direct Memory Access, прямой доступ к памяти) каждые 0.005 секунд, но для этого требуется около 3\% времени процессора, ему может быть выделено время выполнения $ 0.03 \cdot 0.005 = 0.00015 $ секунд. Таким образом, данная группа может быть запланирована с периодом 0.005 секунд с временем выполнения 0.00015 секунд.

Оставшееся процессорное время будет использовано для ввода данных пользователем и других задач.

Однако на текущий момент приведенный выше пример еще не реализован полностью в силу того, что отсутствует реализация планировщика EDF (Erlienst Deadline First scheduling, алгоритм планирования по ближайшему сроку завершения) для использования неоднородных периодов. \cite{linuxkerneldocs}

\subsection{Анализ структур ядра, предоставляющих информацию о приоритетах, времени выполнения и простоя процессов }
\subsubsection{task\_struct}

Структура в ядре Linux, соответствующая каждому процессу, -- task\_struct. Она определена в файле linux/sched.h. \cite{linuxTasks}

Далее будут отмечены требующиеся в работе поля данной структуры (в Linux v5.16rc8).

\paragraph*{pid} (Process Identifier) -- уникальный идентификатор процесса. Каждый процесс в операционной системе имеет свой уникальный идентификатор, по которому можно получить информацию об этом процессе, а также направить ему управляющий сигнал или завершить его \cite{losst}.

prio, static\_prio, normal\_prio, rt\_priority -- приоритеты процесса.

\paragraph*{prio} -- это значение, которое использует планировщик задач при выборе процесса. Чем ниже значение данной переменной, тем выше приоритет процесса (может принимать значения от 0 до 139, то есть MAX\_PRIO, значение которого вычисляется с использованием переменной MAX\_RT\_PRIO со значением 100) \cite{linuxPriority}. Также данный приоритет может быть поделён на два интервала:
\begin{itemize}[leftmargin=1.6\parindent]
\item от 0 до 99 -- процесс реального времени;
\item от 100 до 139 -- обычный процесс.
\end{itemize}

Также описаны функции определения приоритета процесса, которые приведены в листинге \ref{code:prioFunctions}.

\begin{code}
	\captionof{listing}{Функции определения приоритета процесса, описаны в kernel/sched.c}
	\label{code:prioFunctions}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/prios.h}
\end{code}

Из предоставленного листинга видно, что для процессов реального времени значение приоритета определяется с использованием поля prio, а в ином случае -- static\_prio.

\paragraph*{static\_prio} не изменяется ядром при работе планировщика, однако оно может быть изменено с использованием пользовательского приоритета nice. Макрос для изменения данного приоритета предоставлен в листинге \ref{code:nice}.

\begin{code}
	\captionof{listing}{Макрос для изменения static\_prio.}
	\label{code:nice}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/nice.h}
\end{code}

Таким образом, значение статического приоритета может быть изменено с использованием вызова макроса NICE\_TO\_PRIO(nice).

\paragraph*{normal\_prio} зависит от статического приоритета и политики планировщика задач. Для процессов не реального времени данное значение равняется значению статического приоритета static\_prio. Для процессов реального времени данное значение равняется значению, вычисленному с использованием максимального значения приоритета процесса реального времени и, непосредственно, его rt\_priority. Функция вычисления нормального приоритета предоставлена в листинге \ref{code:normal_prio}.

 \begin{code}
	\captionof{listing}{Функция вычисления нормального приоритета. }
	\label{code:normal_prio}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/normal.h}
\end{code}

Важно отметить факт того, что, чем больше значение rt\_priority, тем выше приоритет процесса.

\subsubsection{sched\_info} 
sched\_info -- структура, которая предоставляет информацию о планировании процесса:
\begin{itemize}[leftmargin=1.6\parindent]
\item количество запусков процесса на исполнение центральным процессором;
\item количество времени, проведенного в ожидании на исполнение;
\item время последнего запуска процесса на исполнение центральным процессором;
\item время последнего добавления процесса в очередь на исполнение.
\end{itemize}

Данная структура предоставлена в листинге \ref{code:sched}.

 \begin{code}
	\captionof{listing}{Структура sched\_info. }
	\label{code:sched}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/sched.h}
\end{code}

\paragraph*{utime} -- это время, проведенное в режиме пользователя и затраченное на запуск команд. Данное значение включает в себя только время, затраченное центральным процессором, и не включает в себя время, проведенное процессом в очереди на исполнение.

\paragraph*{stime} -- это время процессора, затраченное на выполнение системных вызовов при исполнении процесса.

\subsection{Анализ способов определения принадлежности задачи к группе задач реального времени}

\subsubsection{Функция rt\_prio}
Реализация функции rt\_prio приведена в листинге \ref{code:rt_prio}.

 \begin{code}
	\captionof{listing}{Функция rt\_prio. }
	\label{code:rt_prio}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/rt_prio.h}
\end{code}

Представленная функция определяет, является ли процесс задачей реального времени, с использованием значения приоритета. Приоритет задачи сравнивается с максимальным значением приоритета для задачи реального времени. В случае, если условие истинно, процесс относится к задачам реального времени и возвращается единица.

Важно отметить, что макрос unlikely в данном случае применяется для оптимизации скорости выполнения сравнения.

\subsubsection{Функция rt\_task}
Реализация данной функции приведена в листинге \ref{code:rt_task}.

 \begin{code}
	\captionof{listing}{Функция rt\_task. }
	\label{code:rt_task}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/rt_task.h}
\end{code}

rt\_task является оберточной функцией для вызова функции rt\_prio. Возвращает единицу в том случае, если процесс является задачей реального времени.

\subsubsection{Функция task\_is\_realtime}
Реализация данной функции приведена в листинге \ref{code:rask_is_realtime}.

 \begin{code}
	\captionof{listing}{Функция task\_is\_realtime. }
	\label{code:rask_is_realtime}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/task_is_realtime.h}
\end{code}

task\_is\_realtime анализирует политику планировщика из преданной структуры task\_struct. SCHED\_FIFO и SCHED\_RR являются политиками реального времени. 

\subsection{Передача данных из пространства ядра в пространство пользователя}
В Linux для передачи данных из пространства ядра в пространство пользователя зачастую используется виртуальная файловая система procfs, которая предоставляет системные вызовы для реализации интерфейса между двумя этими пространствами.

Структура proc\_ops определена в файле linux/proc\_fs.h и содержит в себе указатели на функции драйвера, которые отвечают за выполнение различных операций с устройством. Поля структуры представлены в листинге \ref{code:proc_ops}.

 \begin{code}
	\captionof{listing}{Структура proc\_ops.}
	\label{code:proc_ops}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/proc_ops.h}
\end{code}

Функция copy\_to\_user, определенная в файле linux/uaccess.h, позволяет копировать блоки данных из пространства ядра в пространство пользователя. Возвращает количество байт, которые не удалось скопировать. \cite{universityOfBirningham}

Реализация функции приведена в листинге \ref{code:copy_to_user}.
 \begin{code}
	\captionof{listing}{Реализация функции copy\_to\_user.}
	\label{code:copy_to_user}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/copy_to_user.h}
\end{code}


\subsubsection*{Выводы}
В результате анализа кода ядра определены структуры, содержащие необходимую информацию: task\_struct (поля pid, prio, static\_prio, normal\_prio) и sched\_info (поля run\_delay, utime, stime). Также были определены функции, позволяющие определить, относится ли процесс к задачам реального времени: rt\_prio, rt\_task и task\_is\_realtime.

\pagebreak