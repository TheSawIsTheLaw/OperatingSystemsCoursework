\section{Аналитический раздел}
В данном разделе...

\subsection{Формализация цели}
Цель работы -- разработать загружаемый модуль ядра для мониторинга приоритетов, времени выполнения и простоя процессов на ОС Linux и проанализировать с использованием данного модуля воспроизведение аудиофайлов и видеофайлов.

Для достижения поставленной цели потребуется:
\begin{enumerate}[leftmargin=1.6\parindent]
\item проанализировать структуры ядра, позволяющие определить приоритет, время выполнения и простоя процессов;
\item проанализировать методы передачи информации из модуля ядра в пространство пользователя;
\item спроектировать и реализовать загружаемый модуль ядра;
\item проанализировать с использованием реализованного модуля воспроизведение аудиофайлов и видеофайлов.
\end{enumerate}

\subsection{Понятие процесса реального времени}
Процесс реального времени -- это процесс, который имеет приоритет над обычными процессами. В Linux планирование процессов реального времени возложено на так называемый RT Scheduler (Real Time Scheduler -- планировщик реального времени), а обычные процессы обрабатываются с использованием CFS Scheduler (Completely Fair Scheduler -- совершенно честный планировщик). Работа данных планировщиков строится на работе с группами процессов, которые расположены в очередях, которые, в свою очередь, организованы в дерево. \cite{realtimeprocesses}

\subsection{Описание работы RT Scheduler}
Проблема планирования в режиме реального времени заключается в том, что группы процессов должны полагаться на постоянство объема полосы пропускания (например, времени исполнения). Для планирования нескольких групп задач в реальном времени может потребоваться назначение, так называемого, гарантированного доступного времени исполнения. \cite{linuxkerneldocs}

В качестве решения поставленной проблемы доступное процессорное время делится посредством указания того, сколько времени на исполнение даётся на указанный период. Данное время выделяется для каждой группы процессов реального времени, причём каждая группа может исполнятся только в свое выделенное время. \cite{linuxkerneldocs}

Время, не выделенное группам реального времени или неиспользованное ими, будет выделено задачами с обычным приоритетом (SCHED\_OTHER). \cite{linuxkerneldocs}

Для примера можно рассмотреть следующую задачу: рендерер реального времени с фиксированным количеством кадров должен выдавать 25 кадров в секунду, что дает период 0.04 секунды на каждый кадр. Если перед рендерером также стоит параллельная задача проигрывания музыки и ответа на ввод, оставляя около 80\% доступного процессорного времени, предназначенного для графики, то для этой группы можно выделить время выполнения $ 0.8 \cdot 0.04 = 0.032 $ секунды.

Таким образом, графическая группа будет иметь период 0.04 секунды с ограничением времени выполнения 0.032 секунды. Если аудиопотоку необходимо заполнять буфер DMA (Direct Memory Access, прямой доступ к памяти) каждые 0.005 секунд, но для этого требуется около 3\% времени процессора, ему может быть выделено время выполнения $ 0.03 \cdot 0.005 = 0.00015 $ секунд. Таким образом, данная группа может быть запланирована с периодом 0.005 секунд с временем выполнения 0.00015 секунд.

Оставшееся процессорное время будет использовано для ввода данных пользователем и других задач.

Однако на текущий момент приведенный выше пример еще не реализован полностью в силу того, что отсутствует реализация планировщика EDF (Erlienst Deadline First scheduling, алгоритм планирования по ближайшему сроку завершения) для использования неоднородных периодов. \cite{linuxkerneldocs}

\subsection{Структуры ядра}
Современные операционные системы предоставляют пользователю фундаментальные концепции, такие как, файл или процесс. \cite{linuxTasks}

С использованием документации представляется возможность получить доступ к данным концепциям и изучить работу системы изнутри.

\subsubsection{task\_struct}
Процесс состоит из нескольких компонентов \cite{linuxTasks}:
\begin{itemize}[leftmargin=1.6\parindent]
\item стек процесса;
\item регистры процессора, в которые загружены ключевые переменные (зависит от архитектуры);
\item адресное пространство;
\item ресурсы: дескрипторы открытых файлов, ожидающие обработки сигналы;
\item управляющие структуры ядра ОС.
\end{itemize}

Структура в ядре Linux, соответствующая каждому процессу, -- task\_struct. Она определена в файле include/linux/sched.h. Все процессы существующие в системе процессы объединены в кольцевой список. \cite{linuxTasks} 

Стоит отметить, что данная структура занимает в памяти порядка 1.7 килобайт.

Поля структуры содержат информацию о процессе, которую можно поделить на несколько категорий \cite{linuxTasks}:
\begin{itemize}[leftmargin=1.6\parindent]
\item поля, отвечающие за общую информацию о процессе (PID, exit\_code, PPID);
\item поля, востребованные планировщиком задач (prio, static\_prio, timeslice);
\item поля, связанные с безопасностью (uid, gid).
\end{itemize}

Структура task\_struct для Linux v5.16rc8 представлена в приложении (см. Приложение 1).

Далее будут отмечены наиболее информативные в проводимой работе поля данной структуры и их назначение.

\paragraph*{pid} (Process Identifier) -- уникальный идентификатор процесса. Каждый процесс в операционной системе имеет свой уникальный идентификатор, по которому можно получить информацию об этом процессе, а также направить ему управляющий сигнал или завершить \cite{losst}.

prio, static\_prio, normal\_prio, rt\_priority -- приоритеты процесса.

\paragraph*{prio} -- это значение, которое использует планировщик задач при выборе процесса. Чем ниже значение данной переменное, тем выше приоритет процесса (может принимать значения от 0 до 139, то есть MAX\_PRIO, значение которого вычисляется с использованием переменной MAX\_RT\_PRIO со значением 100) \cite{linuxPriority}. Также данный приоритет может быть поделён на два интервала:
\begin{itemize}[leftmargin=1.6\parindent]
\item от 0 до 99 -- процесс реального времени;
\item от 100 до 139 -- обычный процесс.
\end{itemize}

Также определены функции определения приоритета процесса, которые приведены в листинге \ref{code:prioFunctions}.

\begin{code}
	\captionof{listing}{Функции определения приоритета процесса, определенные в /kernel/sched.c}
	\label{code:prioFunctions}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/prios.h}
\end{code}

Из предоставленного листинга видно, что для процессов реального времени значение приоритета определяется с использованием поля prio, а в ином случае -- static\_prio.

\paragraph*{static\_prio} не изменяется ядром при работе планировщика, однако оно может быть изменено с использованием пользовательского приоритета nice. Макрос для изменения данного приоритета предоставлен в листинге \ref{code:nice}.

\begin{code}
	\captionof{listing}{Макрос для изменения static\_prio.}
	\label{code:nice}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/nice.h}
\end{code}

Таким образом, значение статического приоритета может быть изменено с использованием вызова макроса NICE\_TO\_PRIO(nice).

\paragraph*{normal\_prio} зависит от статического приоритета и политики планировщика задач. Для процессов не реального времени данное значение равняется значению статического приоритета static\_prio. Для процессов реального времени данное значение равняется значению, вычисленному с использованием максимального значения приоритета процесса реального времени и, непосредственно, его rt\_priority. Функция вычисления нормального приоритета предоставлена в листинге \ref{code:normal_prio}.

 \begin{code}
	\captionof{listing}{Функция вычисления нормального приоритета. }
	\label{code:normal_prio}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/normal.h}
\end{code}

Важно отметить факт того, что, чем больше значение rt\_priority, тем выше приоритет процесса.

\subsubsection{sched\_info} 
sched\_info -- структура, которая предоставляет информацию о планировании процесса:
\begin{itemize}[leftmargin=1.6\parindent]
\item количество запусков процесса на исполнение центральным процессором;
\item количество времени, проведенного в ожидании на исполнение;
\item время последнего запуска процесса на исполнение центральным процессором;
\item время последнего добавления процесса в очередь на исполнение.
\end{itemize}

Данная структура предоставлена в листинге \ref{code:sched}.

 \begin{code}
	\captionof{listing}{Структура sched\_info. }
	\label{code:sched}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/sched.h}
\end{code}

\paragraph*{utime} -- это время, проведенное в режиме пользователя и затраченное на запуск команд. Данное значение включает в себя только время, затраченное центральным процессором, и не включает в себя время, проведенное процессом в очереди на исполнение.

\paragraph*{stime} -- это время процессора, затраченное на выполнение системных вызовов при исполнении процесса.

\subsubsection{sched\_rt\_entity} 
sched\_rt\_entity -- это структура, используемая для группового планирования процессов реального времени, которое включает в себя деревья групп и их очередей. Данное решение позволяет определять выделяемую производительность процессора для определенных групп процессов.

Структура sched\_rt\_entity предоставлена в листинге \ref{code:sched}.

 \begin{code}
	\captionof{listing}{Структура sched\_rt\_entity. }
	\label{code:sched}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/sched_rt.h}
\end{code}

В данной структуре поле parent указывает на процесс более высокого уровня в дереве. rt\_rq -- это очередь, в которой процесс находится, а my\_q -- это очередь дочерних процессов.

Поле timeout изменяется так называемым watchdog таймером и используется для проверки того, что процесс не занимает процессор дольше, чем это задано в RLIMIT\_RTTIME.

\subsection{Способы определения принадлежности задачи к группе задач реального времени}
В файле /include/linux/sched/rt.h определены функции, позволяющие определить, является ли процесс задачей реального времени.

\subsubsection{Функция rt\_prio}
Реализация данной функции приведена в листинге \ref{code:rt_prio}.

 \begin{code}
	\captionof{listing}{Функция rt\_prio. }
	\label{code:rt_prio}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/rt_prio.h}
\end{code}

Представленная функция определяет, является ли процесс задачей реального времени, с использованием значения приоритета. Приоритет задачи сравнивается с максимальным значением приоритета для задачи реального времени. В случае, если условие истинно, процесс относится к задачам реального времени и возвращается единица.

Важно отметить, что макрос unlikely в данном случае применяется для оптимизации скорости выполнения сравнения.

\subsubsection{Функция rt\_task}
Реализация данной функции приведена в листинге \ref{code:rt_task}.

 \begin{code}
	\captionof{listing}{Функция rt\_task. }
	\label{code:rt_task}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/rt_task.h}
\end{code}

rt\_task является оберточной функцией для вызова функции rt\_prio. Возвращает единицу в том случае, если процесс является задачей реального времени.

\subsubsection{Функция task\_is\_realtime}
Реализация данной функции приведена в листинге \ref{code:rask_is_realtime}.

 \begin{code}
	\captionof{listing}{Функция task\_is\_realtime. }
	\label{code:rask_is_realtime}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	%firstline=185,
	%lastline=221,
	breaklines=true
	]
	{text}
	{code/task_is_realtime.h}
\end{code}

task\_is\_realtime анализирует политику планировщика из преданной структуры task\_struct. SCHED\_FIFO и SCHED\_RR являются, так называемыми, политиками реального времени. 

SCHED\_FIFO -- это политика панирования реального времени "первый  вошел, первый вышел".   Данный алгоритм планирования не использует интервалов времени, а процесс выполняется до завершения, если он не заблокирован запросом ввода-вывода, вытеснен высокоприоритетным процессом, или он добровольно не отказывается от процессора. \cite{scheduling}

Следует обратить внимание на то, что процесс SCHED\_FIFO, вытесненный другим процессом с более высоким приоритетом, остается во граве списка с его приоритетом и возобновит выполнение, как только все процессы с более высоким приоритетом будут вновь заблокированы. Также, когда процесс SCHED\_FIFO готов к выполнению (например, после пробуждения от операции блокировки), он будет вставлен в конец списка с его приоритетом. \cite{scheduling}

Вызов sched\_setscheduler или sched\_setparam поставит процесс SCHED\_FIFO в начало списка. Как следствие, это может вытеснить исполняющийся в данный момент процесс, если его приоритет такой же, как и у исполняющегося процесса. \cite{scheduling}

SCHED\_RR -- это циклическая (Round-Robin) политика планирования реального времени. Она похожа на SCHED\_FIFO с той лишь разницей, что процессу SCHED\_RR разрешено работать как максимум время кванта. Если процесс SCHED\_RR исчерпывает свой квант времени, он помещается в конец списка с его приоритетом. \cite{scheduling}

Процесс SCHED\_RR, который был вытеснен процессом с более высоким приоритетом, завершит оставшуюся часть своего кванта времени после возобновления выполнения. \cite{scheduling}

Планировщик класса SCHED\_DEADLINE реализует алгоритм EDF (Earliest Deadline First), который основан на идее выбора для выполнения из очереди ожидающих процессов задачи, наиболее близкой к истечению крайнего расчетного времени. SCHED\_DEADLINE поддерживает обеспечение работы процессов, требующих выполнения операций в режиме реального времени, предоставляя для подобных задач гарантированное время выполнения, независимо от общего количества обслуживаемых процессов, и реализуя возможность резервирования пропускной способности процессора для процессов. \cite{sched_deadline}

Как видно из реализации функции, оставшиеся политики планировщика задач не относятся к алгоритмам планирования реального времени.

\subsection{Передача данных из пространства ядра в пространство пользователя}

\subsubsection*{Вывод}
В разделе...

\pagebreak